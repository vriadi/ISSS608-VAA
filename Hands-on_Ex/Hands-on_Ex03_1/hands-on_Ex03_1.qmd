---
title: "Programming Interactive Data Visualisation with R"
author: "Vanessa Riadi"
date: "April 28, 2025"
date-modified: "last-modified"
format:
  html:
    toc: true
execute: 
  echo: true
  eval: true
  warning: false
  freeze: true
---

## [3.1.1]{style="color:#d496d4; background:none;"} Learning Outcome

In this hands-on exercise, we learn how to create interactive data visualisation by using functions provided by **ggiraph** and **plotlyr** packages.

## [3.1.2]{style="color:#d496d4; background:none;"} Getting Started

First, write a code to check, install and launch the following R packages:

-   [**ggiraph**](https://davidgohel.github.io/ggiraph/) for making 'ggplot' graphics interactive.
-   [**plotly**](https://plotly.com/r/), R library for plotting interactive statistical graphs.
-   [**DT**](https://rstudio.github.io/DT/) provides an R interface to the JavaScript library [DataTables](https://datatables.net/) that create interactive table on html page.
-   [**tidyverse**](https://www.tidyverse.org/), a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.
-   [**patchwork**](https://patchwork.data-imaginist.com/) for combining multiple ggplot2 graphs into one figure.

::: callout-note
Install and launch the R packages

```{r}
pacman::p_load(ggiraph, plotly, 
               patchwork, DT, tidyverse) 
```
:::

## [3.1.3]{style="color:#d496d4; background:none;"} Importing Data

In this section, *Exam_data.csv* provided will be used. Using [*read_csv()*](https://readr.tidyverse.org/reference/read_delim.html) of **readr** package, import *Exam_data.csv* into R.

The code below `read_csv()` of **readr** package is used to import *Exam_data.csv* data file into R and save it as an tibble data frame called `exam_data`.

::: {style="font-size: 1.2em"}
```{r}
exam_data <- read_csv("../data/Exam_data.csv")
```
:::

![](images/ss1.jpg){width="444"}

## [3.1.4]{style="color:#d496d4; background:none;"} Interactive Data Visualisation - ggiraph methods

[ggiraph](https://davidgohel.github.io/ggiraph/index.html) ![](images/image1.jpg){width="50"} is an htmlwidget and a ggplot2 extension. It allows ggplot graphics to be interactive.

Interactive is made with [**ggplot geometries**](https://davidgohel.github.io/ggiraph/reference/index.html#section-interactive-geometries) that can understand three arguments:

-   **Tooltip**: a column of data-sets that contain tooltips to be displayed when the mouse is over elements.
-   **Onclick**: a column of data-sets that contain a JavaScript function to be executed when elements are clicked.
-   **Data_id**: a column of data-sets that contain an id to be associated with elements.

If it used within a shiny application, elements associated with an id (data_id) can be selected and manipulated on client and server sides. Refer to this [article](https://www.ardata.fr/ggiraph-book/selections.html) for more detail explanation.

### [3.1.4.1]{style="color:#d496d4; background:none;"} Tooltip effect with *tooltip* aesthetic

Below shows a typical code to plot an interactive statistical graph by using **ggiraph** package. Notice that the code consists of two parts. First, an ggplot object will be created. Next, [`girafe()`](https://davidgohel.github.io/ggiraph/reference/girafe.html) of **ggiraph** will be used to create an interactive svg object.

:::: panel-tabset
## Step 1

First, create the basic graph. We are using interactive version of ggplot2 geom (i.e. [`geom_dotplot_interactive()`](https://davidgohel.github.io/ggiraph/reference/geom_dotplot_interactive.html))

```{r}
#| fig-height: 3
#| fig-width: 8
ggplot(data=exam_data, 
       aes(x = MATHS)) +
geom_dotplot_interactive(
  aes(tooltip = ID),
  stackgroups = TRUE, 
  binwidth = 1, 
  method = "histodot") +
  scale_y_continuous(NULL, breaks = NULL)
```

## Step 2

Next, enable the tooltip using [`girafe()`](https://davidgohel.github.io/ggiraph/reference/girafe.html). This generates an svg object to be displayed on an html page.

::: callout-info
By hovering the mouse pointer on an data point of interest, the student's ID will be displayed.
:::

```{r}
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
girafe(
  ggobj = p,
  #width_svg = 6 if you enable this it will override ur fig-width above
  #height_svg = 6*0.618 if you enable this it will override ur fig-height above
)
```
::::

## [3.1.5]{style="color:#d496d4; background:none;"} Displaying multiple information on tooltip

The content of the tooltip can be customised by including a list object as shown in the code below.

::: callout-info
By hovering the mouse pointer on an data point of interest, the student's ID and Class will be displayed.
:::

```{r}
#| fig-height: 3
exam_data$tooltip <- c(paste0(     
  "Name = ", exam_data$ID,         
  "\n Class = ", exam_data$CLASS)) 

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip), 
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 8,
  #height_svg = 8*0.618
)
```

The first three lines of codes in the code create a new field called *tooltip*. We assign the value ID and CLASS fields into the newly created fields.

```{r}
#| eval: false
exam_data$tooltip <- c(paste0(     
  "Name = ", exam_data$ID,         # We assign the value ID and CLASS fields into the newly created fields. 
  "\n Class = ", exam_data$CLASS)) #\n is to enter to next line
```

This newly created field is used as tooltip field as shown in the code of line 7.

```{r}
#| eval: false
   aes(tooltip = exam_data$tooltip)
```

### ðŸŽ€ [PRACTICE]{style="color:#d496d4"}

Display all information in the tool-top for all subjects by adding more fields in the tooltip

```{r}
#| eval: false
exam_data$tooltip <- c(paste0(     
  "ID = ", exam_data$ID, 
  "\n Class = ", exam_data$CLASS,
  "\n Gender = ", exam_data$GENDER,    
  "\n Race = ", exam_data$GENDER)) 
```

::: panel-tabset
## English

```{r}
#| fig-height: 3
exam_data$tooltip <- c(paste0(     
  "ID = ", exam_data$ID, 
  "\n Class = ", exam_data$CLASS,
  "\n Gender = ", exam_data$GENDER,    
  "\n Race = ", exam_data$GENDER)) 

p <- ggplot(data=exam_data, 
       aes(x = ENGLISH)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip), 
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 8
)
```

## Math

```{r}
#| fig-height: 3
exam_data$tooltip <- c(paste0(     
  "ID = ", exam_data$ID, 
  "\n Class = ", exam_data$CLASS,
  "\n Gender = ", exam_data$GENDER,    
  "\n Race = ", exam_data$GENDER)) 

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip), 
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 8
)
```

## Science

```{r}
#| fig-height: 3
exam_data$tooltip <- c(paste0(     
  "ID = ", exam_data$ID, 
  "\n Class = ", exam_data$CLASS,
  "\n Gender = ", exam_data$GENDER,    
  "\n Race = ", exam_data$GENDER)) 

p <- ggplot(data=exam_data, 
       aes(x = SCIENCE)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip), 
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 8
)
```
:::

## [3.1.6]{style="color:#d496d4; background:none;"} Customising Tooltip style

Code below uses [`opts_tooltip()`](https://davidgohel.github.io/ggiraph/reference/opts_tooltip.html) of **ggiraph** to customize tooltip rendering by add [`css`](https://davidgohel.github.io/ggiraph/reference/opts_tooltip.html#arg-css) declarations.

::: panel-tabset
## white

Background colour of the tooltip is white and the font colour is black and bold

```{r}
#| fig-height: 3
tooltip_css <- "background-color:white; #<<
font-style:bold; color:black;" #<<

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = ID),                   
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,        
  options = list(    #<<
    opts_tooltip(    #<<
      css = tooltip_css)) #<<
)                                        
```

## pink & sans-serif font

Background colour of the tooltip is pink, font colour is black and bold, font family is sans-serif

```{r}
#| fig-height: 3
tooltip_css <- "background-color:pink; #<<
font-style:bold; color:black; font-family:sans-serif" #<<

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = ID),                   
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,
  options = list(    #<<
    opts_tooltip(    #<<
      css = tooltip_css)) #<<
)                                        
```
:::

-   Refer to [Customizing girafe objects](https://www.ardata.fr/ggiraph-book/customize.html) to learn more about how to customise ggiraph objects.

## [3.1.6.1]{style="color:#d496d4; background:none;"} ðŸŽ€ [PRACTICE]{style="color:#d496d4"}

We can customise more items using the arguments from `geom_dotplot_interactive()` [Interactive Parameters](https://davidgohel.github.io/ggiraph/reference/interactive_parameters.html) and `opts_tooltip` [Arguments](https://davidgohel.github.io/ggiraph/reference/opts_tooltip.html) Let's try some of them!

::: panel-tabset
## tooltip

Define what you want to display on hover using [`tooltip`](https://davidgohel.github.io/ggiraph/reference/interactive_parameters.html#arg-tooltip)

```{r}
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = GENDER),
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
girafe(
  ggobj = p
)
```

## fill

Colour your histodot using [`fill`](https://davidgohel.github.io/ggiraph/reference/girafe.html#arg-pointsize)

```{r}
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = GENDER),
    fill = "pink4",
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
girafe(
  ggobj = p
)
```

## opts_tooltip

Change your tooltip background using [`opts_tooltip`](https://davidgohel.github.io/ggiraph/reference/opts_tooltip.html)

```{r}
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = GENDER),
    fill = "pink4",
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
g <- girafe(ggobj = p)

girafe_options(g,
  opts_tooltip(opacity = .7,
    offx = 20, offy = -10,
    use_fill = TRUE, use_stroke = TRUE,
    delay_mouseout = 1000) )

```

## tooltip_css

We can add extra css to further customize tooltip area using [`css`](https://davidgohel.github.io/ggiraph/reference/opts_tooltip.html#arg-css)

```{r}
tooltip_css <- "background-color:pink; 
font-style:bold; color:white; font-family: 'Comic Sans MS', sans-serif;" 
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = GENDER),
    fill = "pink4",
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
g <- girafe(ggobj = p)

girafe_options(g,
  opts_tooltip(
    css = tooltip_css,
    opacity = .7,
    offx = 20, offy = -10,
    use_fill = TRUE, use_stroke = TRUE,
    delay_mouseout = 1000) )

```
:::

## [3.1.6.2]{style="color:#d496d4; background:none;"} Displaying statistics on tooltip

Code below shows an advanced way to customise tooltip. In this example, `tooltip` and [`stat_summary`](https://ggplot2.tidyverse.org/reference/stat_summary.html) are used to compute 90% confident interval of the mean. The derived statistics are then displayed in the tooltip.

```{r}
tooltip <- function(y, ymax, accuracy = .01) {
  mean <- scales::number(y, accuracy = accuracy)
  sem <- scales::number(ymax - y, accuracy = accuracy)
  paste("Mean maths scores:", mean, "+/-", sem)
}

gg_point <- ggplot(data=exam_data, 
                   aes(x = RACE),
) +
  stat_summary(aes(y = MATHS, 
                   tooltip = after_stat(  
                     tooltip(y, ymax))),  
    fun.data = "mean_se", 
    geom = GeomInteractiveCol,  
    fill = "light blue"
  ) +
  stat_summary(aes(y = MATHS),
    fun.data = mean_se,
    geom = "errorbar", width = 0.2, size = 0.2
  )

girafe(ggobj = gg_point)
```

### ðŸŽ€ [PRACTICE]{style="color:#d496d4"}

Use `tooltip` and [`stat_summary`](https://ggplot2.tidyverse.org/reference/stat_summary.html) to show maximum and minimum Maths score for each classes.

```{r}
tooltip <- function(ymin, ymax, accuracy = .01) {
  max <- scales::number(ymax, accuracy = accuracy)
  min <- scales::number(ymin, accuracy = accuracy)
  paste("Max maths scores:", max, "\n Min maths scores:", min)
}

gg_point <- ggplot(data=exam_data, 
                   aes(x = CLASS),
) +
  stat_summary(aes(y = MATHS, 
                   tooltip = after_stat(  
                     tooltip(ymax, ymin))),  
    fun.data = "mean_se", 
    geom = GeomInteractiveCol,  
    fill = "light blue"
  ) +
  stat_summary(aes(y = MATHS),
    fun.data = mean_se,
    geom = "errorbar", width = 0.2, size = 0.2
  )

girafe(ggobj = gg_point)
```

::: callout-note
If no aggregation functions are supplied, will default to mean_se().
:::

## [3.1.6.3]{style="color:#d496d4; background:none;"} Hover effect with *data_id* aesthetic

Code below shows the second interactive feature of ggiraph, namely `data_id`.

::: callout-info
Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over.
:::

```{r}
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(           
    aes(data_id = CLASS),             
    stackgroups = TRUE,               
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(ggobj = p)                                        
```

Note that the default value of the hover css is *hover_css = "fill:orange;"*.

### ðŸŽ€ [PRACTICE]{style="color:#d496d4"}

::: callout-tip
From the note given, means we can edit the `hover_css` using the same method as `girafe_options` that we explored earlier in `opts_tooltip`. Let's try that!
:::

```{r}
#| fig-height: 3
#| fig-width: 8
hover_css <- "fill:deepskyblue;"
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(           
    aes(data_id = CLASS),             
    stackgroups = TRUE,               
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
g <- girafe(ggobj = p)

girafe_options(g, opts_hover(css = hover_css))
```

## [3.1.6.4]{style="color:#d496d4; background:none;"} Styling hover effect

In the code below, css codes are used to change the highlighting effect.

::: callout-info
Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over.
:::

```{r}
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,
  options = list(                        
    opts_hover(css = "fill: #202020;"),  
    opts_hover_inv(css = "opacity:0.2;") 
  )                                        
)                                        
```

::: callout-note
Different from previous example, in this example the ccs customisation request are encoded directly in `options`.
:::

```{r}
#| eval: false
  options = list(                        
    opts_hover(css = "fill: #202020;"),  
    opts_hover_inv(css = "opacity:0.2;") 
```

### ðŸŽ€ [PRACTICE]{style="color:#d496d4"}

::: callout-tip
Using the [`opts_hover`](https://davidgohel.github.io/ggiraph/reference/opts_hover.html) above we can customize the rendering of graphic elements when user hovers over them. Let's try other usages!
:::

```{r}
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,
    fill = "pink",
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,
  options = list(                        
    opts_hover(css = "fill: red;"),  
    opts_hover_inv(css = "fill:black; opacity:0.2;") 
  )                                        
)                                        
```

## [3.1.6.5]{style="color:#d496d4; background:none;"} Combining tooltip and hover effect

There are time that we want to combine tooltip and hover effect on the interactive statistical graph as shown in the code below.

::: callout-info
Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over. At the same time, the tooltip will show the CLASS.
:::

```{r}
#| fig-height: 3
#| fig-width: 8
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = CLASS,
        data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,    
  options = list(                         
    opts_hover(css = "fill: #202020;"),  
    opts_hover_inv(css = "opacity:0.2;")
  )
)                                        
```

## [3.1.6.6]{style="color:#d496d4; background:none;"} Click effect with **onclick**

`onclick` argument of ggiraph provides hotlink interactivity on the web.

The code below shown an example of `onclick`.

::: callout-info
Interactivity: Web document link with a data object will be displayed on the web browser upon mouse click.
:::

```{r}
#| fig-height: 3
#| fig-width: 8
exam_data$onclick <- sprintf("window.open(\"%s%s\")",
"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school", as.character(exam_data$ID) )

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(onclick = onclick),              #<<
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6)
```

::: callout-warning
Note that click actions must be a string column in the dataset containing valid javascript instructions.
:::

## [3.1.6.7]{style="color:#d496d4; background:none;"} Coordinated Multiple Views with **ggiraph**

Coordinated multiple views methods has been implemented in the data visualisation below.

```{r}
#| fig-height: 3
#| fig-width: 8
#| echo: false
p1 <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) +
  scale_y_continuous(NULL,               
                     breaks = NULL)

p2 <- ggplot(data=exam_data, 
       aes(x = ENGLISH)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) +
  scale_y_continuous(NULL,               
                     breaks = NULL)

girafe(code = print(p1 + p2),
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill: #202020;"),
         opts_hover_inv(css = "opacity:0.2;")
         )
       )                                        
```

Notice that when a data point of one of the dotplot is selected, the corresponding data point ID on the second data visualisation will be highlighted too.

In order to build a coordinated multiple views as shown in the example above, the following programming strategy will be used:

1.  Appropriate interactive functions of **ggiraph** will be used to create the multiple views.
2.  *patchwork* function of [patchwork](https://patchwork.data-imaginist.com/) package will be used inside girafe function to create the interactive coordinated multiple views.

#### ðŸŽ€ [PRACTICE]{style="color:#d496d4"}

::: callout-tip
We've learned about patchwork before [here](https://isss608-vriadi.netlify.app/hands-on_ex/hands-on_ex02/hands-on_ex02#creating-composite-graphics-pathwork-methods) in Hands-on Exercise 2. Hence we know that you can also do other ways to combine graphs. Let's try it below!
:::

::: panel-tabset
## Side-by-side

Using `+` in `print(p1 + p2)`

```{r}
#| echo: false
p1 <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +  
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

p2 <- ggplot(data=exam_data, 
       aes(x = ENGLISH)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

girafe(code = print(p1 + p2), 
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill: #202020;"),
         opts_hover_inv(css = "opacity:0.2;")
         )
       ) 
```

```{r}
#| eval: false
p1 <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +  
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

p2 <- ggplot(data=exam_data, 
       aes(x = ENGLISH)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

girafe(code = print(p1 + p2), 
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill: #202020;"),
         opts_hover_inv(css = "opacity:0.2;")
         )
       ) 
```

## Top and bottom

Using `/` in `print(p1 / p2)`

```{r}
#| echo: false
p1 <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) +
  scale_y_continuous(NULL,               
                     breaks = NULL)

p2 <- ggplot(data=exam_data, 
       aes(x = ENGLISH)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) +
  scale_y_continuous(NULL,               
                     breaks = NULL)

girafe(code = print(p1 / p2),
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill: #202020;"),
         opts_hover_inv(css = "opacity:0.2;")
         )
       )                                        
```

```{r}
#| eval: false
p1 <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) +
  scale_y_continuous(NULL,               
                     breaks = NULL)

p2 <- ggplot(data=exam_data, 
       aes(x = ENGLISH)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) +
  scale_y_continuous(NULL,               
                     breaks = NULL)

girafe(code = print(p1 / p2),
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill: #202020;"),
         opts_hover_inv(css = "opacity:0.2;")
         )
       )                                        
```
:::

The *data_id* aesthetic is critical to link observations between plots and the tooltip aesthetic is optional but nice to have when mouse over a point.

## [3.1.7]{style="color:#d496d4; background:none;"} Interactive Data Visualisation - plotly methods!

Plotly's R graphing library create interactive web graphics from **ggplot2** graphs and/or a custom interface to the (MIT-licensed) JavaScript library [**plotly.js**](https://plotly.com/javascript/) inspired by the grammar of graphics. Different from other plotly platform, plot.R is free and open source.

![](images/image2.jpg)

There are two ways to create interactive graph by using plotly, they are:

-   by using *plot_ly()*, and
-   by using *ggplotly()*

### [3.1.7.1]{style="color:#d496d4; background:none;"} Creating an interactive scatter plot: plot_ly() method

The tabset below shows an example a basic interactive plot created by using [`plot_ly()`](https://plotly.com/r/getting-started/).

::: panel-tabset
## The plot

```{r}
#| echo: false
plot_ly(data = exam_data, 
             x = ~MATHS, 
             y = ~ENGLISH)
```

## The code chunk

```{r}
#| eval: false
plot_ly(data = exam_data, 
             x = ~MATHS, 
             y = ~ENGLISH)
```
:::

### [3.1.7.2]{style="color:#d496d4; background:none;"} Working with visual variable: plot_ly() method

In the code below, *color* argument is mapped to a qualitative visual variable (i.e. RACE).

::: panel-tabset
## The plot

```{r}
#| echo: false
plot_ly(data = exam_data, 
        x = ~ENGLISH, 
        y = ~MATHS, 
        color = ~RACE)
```

Interactive:

-   Click on the colour symbol at the legend.

## The code chunk

```{r}
#| eval: false
plot_ly(data = exam_data, 
        x = ~ENGLISH, 
        y = ~MATHS, 
        color = ~RACE)
```
:::

### [3.1.7.3]{style="color:#d496d4; background:none;"} Creating an interactive scatter plot: ggplotly() method

The code below plots an interactive scatter plot by using *ggplotly()*.

::: panel-tabset
## The plot

```{r}
#| echo: false
p <- ggplot(data=exam_data, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(dotsize = 1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))
ggplotly(p)
```

## The code chunk

```{r}
#| eval: false
p <- ggplot(data=exam_data, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))
ggplotly(p)

```

Notice that the only extra line you need to include in the code is *ggplotly()*.
:::

### [3.1.7.4]{style="color:#d496d4; background:none;"} Coordinated Multiple Views with **plotly**

The creation of a coordinated linked plot by using plotly involves three steps:

-   [`highlight_key()`](https://www.rdocumentation.org/packages/plotly/versions/4.9.2/topics/highlight_key) of **plotly** package is used as shared data.
-   two scatterplots will be created by using ggplot2 functions.
-   lastly, [*subplot()*](https://plotly.com/r/subplots/) of **plotly** package is used to place them next to each other side-by-side.

::: callout-note
Click on a data point of one of the scatterplot and see how the corresponding point on the other scatterplot is selected.
:::

::: panel-tabset
## The plot

```{r}
#| echo: false
d <- highlight_key(exam_data)  
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))
subplot(ggplotly(p1),
        ggplotly(p2))
```

## The code

```{r}
#| eval: false
d <- highlight_key(exam_data)  
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))
subplot(ggplotly(p1),
        ggplotly(p2))
```

Thing to learn from the code chunk:

-   `highlight_key()` simply creates an object of class [crosstalk::SharedData](https://rdrr.io/cran/crosstalk/man/SharedData.html).\
-   Visit this [link](https://rstudio.github.io/crosstalk/) to learn more about crosstalk,
:::

### ðŸŽ€ [PRACTICE]{style="color:#d496d4"}

::: callout-tip
When we hover on the `subplot` keyword in RStudio, we can see what attributes are available like this: ![](images/ss2.jpg)
:::

Since the example code given above are not clear enough (doesn't state X & Y label), we should add them in. Let's also try other configuration to combine the plots!

::: panel-tabset
## Side By Side Subplots

```{r}
#| echo: false
d <- highlight_key(exam_data)  
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))


fig <- subplot(ggplotly(p1),
        ggplotly(p2), titleX = TRUE, titleY = TRUE, margin = 0.08) %>% 
  layout(title = 'Side By Side Subplots', margin = list(t = 50))
fig
```

```{r}
#| eval: false
d <- highlight_key(exam_data)  
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))


fig <- subplot(ggplotly(p1),
        ggplotly(p2), titleX = TRUE, titleY = TRUE, margin = 0.08) %>% 
  layout(title = 'Side By Side Subplots', margin = list(t = 50))
fig
```

## Stacked Subplots

```{r}
#| echo: false
d <- highlight_key(exam_data)  
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

fig <- subplot(ggplotly(p1),
        ggplotly(p2), nrows = 2, titleX = TRUE, titleY = TRUE, margin = 0.08) %>% 
  layout(title = 'Stacked Subplots', margin = list(t = 50))
fig
```

```{r}
#| eval: false
d <- highlight_key(exam_data)  
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

fig <- subplot(ggplotly(p1),
        ggplotly(p2), nrows = 2, titleX = TRUE, titleY = TRUE, margin = 0.12) %>% 
  layout(title = 'Stacked Subplots', margin = list(t = 50))
fig
```

## Multiple Subplots

2 x 2 subplot grid and populating each subplot with scatter trace.

```{r}
#| echo: false
d <- highlight_key(exam_data)  
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p3 <- ggplot(data=d, 
            aes(x = ENGLISH,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

fig <- subplot(ggplotly(p1),
        ggplotly(p2), ggplotly(p3), nrows = 2, titleX = TRUE, titleY = TRUE, margin = 0.08) %>% 
  layout(title = 'Multiple Subplots', margin = list(t = 50))
fig
```

```{r}
#| eval: false
d <- highlight_key(exam_data)  
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p3 <- ggplot(data=d, 
            aes(x = ENGLISH,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

fig <- subplot(ggplotly(p1),
        ggplotly(p2), ggplotly(p3), nrows = 2, titleX = TRUE, titleY = TRUE, margin = 0.08) %>% 
  layout(title = 'Multiple Subplots', margin = list(t = 50))
fig
```
:::

## [3.1.8]{style="color:#d496d4; background:none;"} Interactive Data Visualisation - crosstalk methods!

[Crosstalk](https://rstudio.github.io/crosstalk/index.html) is an add-on to the htmlwidgets package. It extends htmlwidgets with a set of classes, functions, and conventions for implementing cross-widget interactions (currently, linked brushing and filtering).

### [3.1.8.1]{style="color:#d496d4; background:none;"} Interactive Data Table: DT package

-   A wrapper of the JavaScript Library [DataTables](https://datatables.net/)

-   Data objects in R can be rendered as HTML tables using the JavaScript library 'DataTables' (typically via R Markdown or Shiny).

```{r}
DT::datatable(exam_data, class= "compact")
```

#### ðŸŽ€ [PRACTICE]{style="color:#d496d4"}

::: callout-tip
More info and arguments that we can use on [`Datatables`](https://rstudio.github.io/DT/). Let's try some!
:::

::: panel-tabset
## Page length

```{r}
DT::datatable(exam_data , options = list(
  columnDefs = list(list(className = 'dt-center', targets = 5)),
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20)
))

```

## Header color

```{r}
DT::datatable(exam_data, options = list(
  columnDefs = list(list(className = 'dt-center', targets = 5)),
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20),
  initComplete = JS(
    "function(settings, json) {",
    "$(this.api().table().header()).css({'background-color': '#000', 'color': '#fff'});",
    "}")
))

```

## Select specific column

DataTables does not provide column filters by default. Thus we can work around this by selecting the column and defining a new variable `exam_data_selected`

```{r}
exam_data_selected <- exam_data %>%
  select(ID, CLASS, GENDER, ENGLISH, MATHS, SCIENCE)

DT::datatable(exam_data_selected, options = list(
  columnDefs = list(list(className = 'dt-center', targets = 5)),
  pageLength = 5,
  lengthMenu = c(5, 10, 15, 20),
  initComplete = JS(
    "function(settings, json) {",
    "$(this.api().table().header()).css({'background-color': '#000', 'color': '#fff'});",
    "}")
))
```
:::

### [3.1.8.2]{style="color:#d496d4; background:none;"} Linked brushing: crosstalk method

::: panel-tabset
## The plot

```{r}
#| echo: FALSE
d <- highlight_key(exam_data_selected)
p <- ggplot(d, aes(ENGLISH, MATHS)) + 
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

gg <- highlight(ggplotly(p), 
                "plotly_selected")

crosstalk::bscols(gg, DT::datatable(d), widths = 5)
```

## The code chunk

Code below is used to implement the coordinated brushing shown above.

```{r eval=FALSE}
d <- highlight_key(exam_data_selected)
p <- ggplot(d, aes(ENGLISH, MATHS)) + 
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

gg <- highlight(ggplotly(p), 
                "plotly_selected")

crosstalk::bscols(gg, DT::datatable(d), widths = 5)     
```

Things to learn from the code chunk:

-   *highlight()* is a function of **plotly** package. It sets a variety of options for brushing (i.e., highlighting) multiple plots. These options are primarily designed for linking multiple plotly graphs, and may not behave as expected when linking plotly to another htmlwidget package via crosstalk. In some cases, other htmlwidgets will respect these options, such as persistent selection in leaflet.

-   *bscols()* is a helper function of [`crosstalk`](https://rstudio.github.io/crosstalk/using.html) package. It makes it easy to put HTML elements side by side. It can be called directly from the console but is especially designed to work in an R Markdown document. **Warning:** This will bring in all of Bootstrap!.
:::

## [3.1.9]{style="color:#d496d4; background:none;"} Reference

### [3.1.9.1]{style="color:#d496d4; background:none;"} ggiraph

This [link](https://davidgohel.github.io/ggiraph/index.html) provides online version of the reference guide and several useful articles. Use this [link](https://cran.r-project.org/web/packages/ggiraph/ggiraph.pdf) to download the pdf version of the reference guide.

-   [How to Plot With Ggiraph](https://www.r-bloggers.com/2018/04/how-to-plot-with-ggiraph/)
-   [Interactive map of France with ggiraph](http://rstudio-pubs-static.s3.amazonaws.com/152833_56a4917734204de7b37881d164cf8051.html)\
-   [Custom interactive sunbursts with ggplot in R](https://www.pipinghotdata.com/posts/2021-06-01-custom-interactive-sunbursts-with-ggplot-in-r/)
-   This [link](https://github.com/d-qn/2016_08_02_rioOlympicsAthletes) provides code example on how ggiraph is used to interactive graphs for [Swiss Olympians - the solo specialists](https://www.swissinfo.ch/eng/rio-2016-_swiss-olympiansthe-solo-specialists-/42349156?utm_content=bufferd148b&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer).

### [3.1.9.2]{style="color:#d496d4; background:none;"} plotly for R

-   [Getting Started with Plotly in R](https://plotly.com/r/getting-started/)
-   A collection of plotly R graphs are available via this [link](https://plotly.com/r/).
-   Carson Sievert (2020) **Interactive web-based data visualization with R, plotly, and shiny**, Chapman and Hall/CRC is the best resource to learn plotly for R. The online version is available via this [link](https://plotly-r.com/)
-   [Plotly R Figure Reference](https://plotly.com/r/reference/index/) provides a comprehensive discussion of each visual representations.
-   [Plotly R Library Fundamentals](https://plotly.com/r/plotly-fundamentals/) is a good place to learn the fundamental features of Plotly's R API.
-   [Getting Started](https://gganimate.com/articles/gganimate.html)
-   Visit this [link](https://rpubs.com/raymondteo/dataviz8) for a very interesting implementation of gganimate by your senior.
-   [Building an animation step-by-step with gganimate](https://www.alexcookson.com/post/2020-10-18-building-an-animation-step-by-step-with-gganimate/).
-   [Creating a composite gif with multiple gganimate panels](https://solarchemist.se/2021/08/02/composite-gif-gganimate/)
